                  If CLng(intIntSize) >= CLng(INITIAL_SIZE_LB) Then
                                    ' check for overflows
                                    If Err.Number Then
                                        Err.Clear
                                        ' get the upper bound allowed for maximum size
                                        intMaxSizeUB = getMaxSizeUB(objService)
                                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If
                                    ' get the drive name first
                                    strDriveName = Mid(objInstance.Name,1,2)
                                    ' get the free space available on the specified disk
                                    intFreeDiskSpace = getFreeSpaceOnDisk(strDriveName,objService)
                                    ' get the current pagefile size
                                    intCurrentSize = getCurrentPageFileSize(objService,objInstance)
                                    ' get the total free space
                                    If Len(intCurrentSize) > 0 Then
                                        intFreeSpace = intFreeDiskSpace + intCurrentSize
                                    Else
                                        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
                                        WScript.Quit(EXIT_QUERY_FAIL)
                                    End If
                                    ' Check if it is greater than free disk space
                                    If CLng(intIntSize) > CLng(intFreeSpace) Then
                                        ' check for overflows
                                        If Err.Number Then
                                            Err.Clear
                                            ' get the upper bound allowed for maximum size
                                            intMaxSizeUB = getMaxSizeUB(objService)
                                            component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                            Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        WScript.Echo(NotEnoughSpaceErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    Else
                                        If CLng(intIntSize) > CLng(intFreeSpace) - 5 Then
                                            ' check for overflows
                                            If Err.Number Then
                                                Err.Clear
                                                WScript.Echo(L_InvalidInput_ErrorMessage)
                                                WScript.Quit(EXIT_INVALID_INPUT)
                                            End If
                                            WScript.Echo(AtLeastFiveMBErrorMessage)
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        Else
                                            ' only one of initsize, maxsize is specified
                                            ' check if the specified initsize is less than existing maxsize
                                            If (CInt(intIntSize) <= objInstance.MaximumSize) Then
                                                ' get the crash dump setting value
                                                intCrashDump = GetCrashDumpSetting(strUserName,strPassword,strMachine)
                                                ' get the Physical Memory Size
                                                intMemSize = GetPhysicalMemorySize(strHostName,objService)
                                                ' If the user has selected "yes" for the warning message
                                                If isCrashDumpValueSet(intCrashDump,intIntSize,intMemSize,arrVolume(i)) Then
                                                    ' Check if initsize is same as the present value
                                                    If (CInt(intIntSize) <> objInstance.InitialSize) Then
                                                        ' store the old initsize value
                                                        intOldInitialSize = objInstance.InitialSize
                                                        ' set the new initsize
                                                        objInstance.InitialSize = intIntSize
                                                        objInstance.Put_(CONST_WBEM_FLAG)
                                                        If Err.Number Then
                                                            Err.Clear
                                                            WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                            WScript.Quit(EXIT_INVALID_INPUT)
                                                        End If
                                                        component.VBPrintf ChangeIntSuccessMessage, _
                                                        Array(UCase(arrVolume(i)),CInt(intOldInitialSize),CInt(intIntSize))
                                                        blnSuccessMsg = TRUE
                                                    Else
                                                        component.VBPrintf ChangeIntSkippingMessage, Array(UCase(arrVolume(i)))
                                                    End If
                                                End If
                                            Else
                                                ' get the upper bound allowed for maximum size
                                                intMaxSizeUB = getMaxSizeUB(objService)
                                                component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                                Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                            End If
                                        End If
                                    End If
                                Else
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InitialSizeRangeErrorMessage, _
                                    Array(intMaxSizeUB)
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                            Else
                                ' Check if initsize specified as 0
                                If Len(intIntSize) > 0 Then
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InitialSizeRangeErrorMessage, _
                                    Array(intMaxSizeUB)
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                            End If ' initsize checked

                            ' check if maxsize is given
                            If (intMaxSize > 0) Then
                                ' get the free space available on the specified disk
                                intFreeDiskSpace = getFreeSpaceOnDisk(strDriveName,objService)
                                ' get the current pagefile size
                                intCurrentSize = getCurrentPageFileSize(objService,objInstance)
                                ' get the total free space
                                If Len(intCurrentSize) > 0 Then
                                    intFreeSpace = intFreeDiskSpace + intCurrentSize
                                Else
                                    WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
                                    WScript.Quit(EXIT_QUERY_FAIL)
                                End If

                                ' Get the Disk Size for the specified drive
                                intDiskSize = GetDiskSize(arrVolume(i),objService)
                                ' check if maxsize is more than initsize
                                If (CLng(intMaxSize) > CLng(intDiskSize)) Then
                                    ' check for overflows
                                    If Err.Number Then
                                        Err.Clear
                                        ' get the upper bound allowed for maximum size
                                        intMaxSizeUB = getMaxSizeUB(objService)
                                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If
                                    component.VBPrintf DiskTooSmallErrorMessage, Array(UCase(arrVolume(i)))
                                Else
                                    If (CLng(intMaxSize) > CLng(intFreeSpace)) Then
                                        ' check for overflows
                                        If Err.Number Then
                                            Err.Clear
                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        component.VBPrintf GrowsToFreeSpaceWarningMessage, _
                                        Array(UCase(arrVolume(i)),intFreeSpace)
                                        strReply = getReply()
                                        If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                                            ' set the maxsize to be the free space on disk
                                            intMaxSize = intFreeSpace
                                            ' check if the given maxsize is greater than the existing initial size.
                                            If (CInt(intMaxSize) >= objInstance.InitialSize) Then
                                                If (CInt(intMaxSize) <> objInstance.MaximumSize) Then
                                                    intOldMaximumSize = objInstance.MaximumSize
                                                    objInstance.MaximumSize = intMaxSize
                                                    objInstance.Put_(CONST_WBEM_FLAG)
                                                    If Err.Number Then
                                                        Err.Clear
                                                        WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                        WScript.Quit(EXIT_INVALID_INPUT)
                                                    End If
                                                    component.VBPrintf ChangeMaxSuccessMessage, _
                                                    Array(UCase(arrVolume(i)),CInt(intOldMaximumSize),CInt(intMaxSize))
                                                    blnSuccessMsg = TRUE
                                                Else
                                                    component.VBPrintf ChangeMaxSkippingMessage, Array(UCase(arrVolume(i)))
                                                End If
                                            Else
                                                ' get the upper bound allowed for maximum size
                                                intMaxSizeUB = getMaxSizeUB(objService)
                                                component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                                Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                            End If
                                        ElseIf LCase(strReply) = L_UserReplyNo_Text Then
                                            WScript.Quit(EXIT_SUCCESS)
                                        Else
                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                            WScript.Quit (EXIT_INVALID_INPUT)
                                        End If
                                    Else
                                        If (CInt(intMaxSize) >= objInstance.InitialSize) Then
                                            If (CInt(intMaxSize) <> objInstance.MaximumSize) Then
                                                intOldMaximumSize = objInstance.MaximumSize
                                                objInstance.MaximumSize = intMaxSize
                                                objInstance.Put_(CONST_WBEM_FLAG)
                                                If Err.Number Then
                                                    Err.Clear
                                                    WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                    WScript.Quit(EXIT_INVALID_INPUT)
                                                End If
                                                component.VBPrintf ChangeMaxSuccessMessage, _
                                                Array(UCase(arrVolume(i)),CInt(intOldMaximumSize),CInt(intMaxSize))
                                                blnSuccessMsg = TRUE
                                            Else
                                                component.VBPrintf ChangeMaxSkippingMessage, Array(UCase(arrVolume(i)))
                                            End If
                                        Else
                                            ' get the upper bound allowed for maximum size
                                            intMaxSizeUB = getMaxSizeUB(objService)
                                            component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                            Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                        End If
                                    End If
                                End If
                            Else
                                ' Check if maxsize specified as 0
                                If Len(intMaxSize) > 0 Then
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                    Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                End If
                            End If ' maxsize checked

                        Else

                            ' Case when both initsize and maxsize are selected

                            ' check if maxsize is greater than initsize
                            ' this will detect any overflow problems, if any
                            If CLng(intIntSize) > CLng(intMaxSize) Then
                                ' check for overflows and clear the error
                                If Err.Number Then Err.Clear
                                ' get the upper bound allowed for maximum size
                                intMaxSizeUB = getMaxSizeUB(objService)
                                component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If

                            If (intIntSize > 0) Then
                                ' Check if initsize is greater than 2 MB
                                If CLng(intIntSize) >= CLng(INITIAL_SIZE_LB) Then
                                    ' check for overflows
                                    If Err.Number Then
                                        Err.Clear
                                        ' get the upper bound allowed for maximum size
                                        intMaxSizeUB = getMaxSizeUB(objService)
                                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If

                                    ' get the free space available on the specified disk
                                    intFreeDiskSpace = getFreeSpaceOnDisk(strDriveName,objService)
                                    ' get the current pagefile size
                                    intCurrentSize = getCurrentPageFileSize(objService,objInstance)
                                    ' get the total free space
                                    If Len(intCurrentSize) > 0 Then
                                        intFreeSpace = intFreeDiskSpace + intCurrentSize
                                    Else
                                        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
                                        WScript.Quit(EXIT_QUERY_FAIL)
                                    End If

                                    ' check if it is greater than free disk space
                                    If CLng(intIntSize) > CLng(intFreeSpace) Then
                                        ' check for overflows
                                        If Err.Number Then
                                            Err.Clear
                                            ' get the upper bound allowed for maximum size
                                            intMaxSizeUB = getMaxSizeUB(objService)
                                            component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                            Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        WScript.Echo(NotEnoughSpaceErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If

                                    If CLng(intIntSize) > CLng(intFreeSpace) - 5 Then
                                        ' check for overflows
                                        If Err.Number Then
                                            Err.Clear
                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        WScript.Echo(AtLeastFiveMBErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    Else
                                        ' get the crash dump setting value
                                        intCrashDump = GetCrashDumpSetting(strUserName,strPassword,strMachine)
                                        ' get the Physical Memory Size
                                        intMemSize = GetPhysicalMemorySize(strHostName,objService)
                                        ' If the user has selected "yes" for the warning message
                                        If isCrashDumpValueSet(intCrashDump,intIntSize,intMemSize,arrVolume(i)) Then
                                            ' store the old initsize value
                                            intOldInitialSize = objInstance.InitialSize
                                            ' set the new initsize
                                            objInstance.InitialSize = intIntSize
                                            ' check if maxsize is given
                                            If (intMaxSize > 0) Then
                                                ' Get the Disk Size for the specified drive
                                                intDiskSize = GetDiskSize(arrVolume(i),objService)
                                                ' check if maxsize is more than initsize
                                                If (CLng(intMaxSize) > CLng(intDiskSize)) Then
                                                    ' check for overflows
                                                    If Err.Number Then
                                                        Err.Clear
                                                        ' get the upper bound allowed for maximum size
                                                        intMaxSizeUB = getMaxSizeUB(objService)
                                                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                                        WScript.Quit(EXIT_INVALID_INPUT)
                                                    End If
                                                    component.VBPrintf DiskTooSmallErrorMessage, _
                                                    Array(UCase(arrVolume(i)))
                                                Else
                                                    If (CLng(intMaxSize) > CLng(intFreeSpace)) Then
                                                        ' check for overflows
                                                        If Err.Number Then
                                                            Err.Clear
                                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                                            WScript.Quit(EXIT_INVALID_INPUT)
                                                        End If
                                                        component.VBPrintf GrowsToFreeSpaceWarningMessage, _
                                                        Array(UCase(arrVolume(i)),intFreeSpace)
                                                        strReply = getReply()
                                                        If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                                                            ' set the maxsize to be the free space on disk
                                                            intMaxSize = intFreeSpace
                                                            intOldMaximumSize = objInstance.MaximumSize
                                                            objInstance.MaximumSize = intMaxSize
                                                            If ( CInt(intIntSize) <> intOldInitialSize ) Then
                                                                objInstance.Put_(CONST_WBEM_FLAG)
                                                                If Err.Number Then
                                                                    Err.Clear
                                                                    WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                                    WScript.Quit(EXIT_INVALID_INPUT)
                                                                End If
                                                                component.VBPrintf ChangeIntSuccessMessage, _
                                                                Array(UCase(arrVolume(i)),CInt(intOldInitialSize),CInt(intIntSize))
                                                                blnSuccessMsg = TRUE
                                                            Else
                                                                component.VBPrintf ChangeIntSkippingMessage, _
                                                                Array(UCase(arrVolume(i)))
                                                            End If
                                                            If (CInt(intMaxSize) <> intOldMaximumSize) Then
                                                                objInstance.Put_(CONST_WBEM_FLAG)
                                                                If Err.Number Then
                                                                    Err.Clear
                                                                    WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                                    WScript.Quit(EXIT_INVALID_INPUT)
                                                                End If
                                                                component.VBPrintf ChangeMaxSuccessMessage, _
                                                                Array(UCase(arrVolume(i)),CInt(intOldMaximumSize),CInt(intMaxSize))
                                                                blnSuccessMsg = TRUE
                                                            Else
                                                                component.VBPrintf ChangeMaxSkippingMessage, _
                                                                Array(UCase(arrVolume(i)))
                                                            End If
                                                        ElseIf LCase(strReply) = L_UserReplyNo_Text Then
                                                            WScript.Quit(EXIT_SUCCESS)
                                                        Else
                                                            WScript.Echo(L_InvalidInput_ErrorMessage)
                                                            WScript.Quit (EXIT_INVALID_INPUT)
                                                        End If
                                                    Else
                                                        intOldMaximumSize = objInstance.MaximumSize
                                                        objInstance.MaximumSize = intMaxSize
                                                        objInstance.Put_(CONST_WBEM_FLAG)
                                                        If Err.Number Then
                                                            Err.Clear
                                                            WScript.Echo(L_UpdateFailed_ErrorMessage)
                                                            WScript.Quit(EXIT_INVALID_INPUT)
                                                        End If

                                                        If (CInt(intIntSize) <> intOldInitialSize ) Then
                                                            component.VBPrintf ChangeIntSuccessMessage, _
                                                            Array(UCase(arrVolume(i)),CInt(intOldInitialSize),CInt(intIntSize))
                                                            blnSuccessMsg = TRUE
                                                        Else
                                                            component.VBPrintf ChangeIntSkippingMessage, Array(UCase(arrVolume(i)))
                                                        End If

                                                        If (CInt(intMaxSize) <> intOldMaximumSize) Then
                                                            component.VBPrintf ChangeMaxSuccessMessage, _
                                                            Array(UCase(arrVolume(i)),CInt(intOldMaximumSize),CInt(intMaxSize))
                                                            blnSuccessMsg = TRUE
                                                        Else
                                                            component.VBPrintf ChangeMaxSkippingMessage, Array(UCase(arrVolume(i)))
                                                        End If
                                                    End If
                                                End If
                                            Else
                                                ' Check if maxsize specified as 0
                                                If Len(intMaxSize) > 0 Then
                                                    ' get the upper bound allowed for maximum size
                                                    intMaxSizeUB = getMaxSizeUB(objService)
                                                    component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                                    Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                                End If
                                            End If ' maxsize checked
                                        End If
                                    End If
                                Else
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InitialSizeRangeErrorMessage, _
                                    Array(intMaxSizeUB)
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                            Else
                                ' Check if initsize specified as 0
                                If Len(intIntSize) > 0 Then
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InitialSizeRangeErrorMessage, _
                                    Array(intMaxSizeUB)
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                            End If ' initsize checked
                        End If
                    End If
                Next
            Else
                component.VBPrintf L_PageFileDoesNotExist_ErrorMessage, _
                Array(UCase(arrVolume(i)))
            End If
        Else
            ' the drive does not exist
            component.VBPrintf L_InvalidVolumeName_ErrorMessage, _
            Array(UCase(arrVolume(i)))
            ' remove the drive name from the valid drives list
            objVols.Remove arrVolume(i)
            ' decrement the loop count
            i = i - 1
            ' check for the no.of valid drive names from the specified list.
            If Cint(objVols.Count) = 0 Then
                WScript.Quit(EXIT_INVALID_INPUT)
            Else
                intVolumes = objVols.Count
                arrVolume  = objVols.keys
            End If
        End If
        i = i + 1
    Loop

    If blnSuccessMsg = TRUE then
        WScript.Echo L_RestartComputer_Message
    End If

End Sub

'******************************************************************************
'* Sub:     ProcessCreate
'*
'* Purpose: Creates new page files with the given specifications
'*
'* Input:
'*  [in]    strMachine         machine to configure page files on
'*  [in]    strUserName        user name to connect to the machine
'*  [in]    strPassword        password for the user
'*  [in]    intIntSize         the initial size for the page file
'*  [in]    intMaxSize         the maximum size for the page file
'*  [in]    objVols            the object containing volume names
'*
'* Output:  Displays error message and quits if connection fails
'*
'******************************************************************************
Private Sub ProcessCreate( ByVal strMachine,  _
                           ByVal strUserName, _
                           ByVal strPassword, _
                           ByVal intIntSize,  _
                           ByVal intMaxSize,  _
                           ByVal objVols      )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim arrVolume             ' to store all the volumes specified
    Dim intVolumes            ' to store the no.of volumes specified
    Dim strQuery              ' to store the query for pagefiles
    Dim strQueryDisk          ' to store the query for disk
    Dim strQueryComp          ' to store the query for getting host name
    Dim objService            ' service object
    Dim objInst               ' instance object
    Dim objInstance           ' instance object
    Dim objNewInstance        ' instance object
    Dim objEnum               ' collection object for query results
    Dim objEnumforDisk        ' collection object for query results
    Dim blnSuccessMsg         ' flag to check if a SUCCESS message is generated
    Dim intFreeSpace          ' to store total free space
    Dim intFreeDiskSpace      ' to store free disk space
    Dim intCurrentSize        ' to store the current pagefile size
    Dim intDiskSize           ' to store the disk size for the specified disk
    Dim intMemSize            ' to store physical memory size
    Dim intCrashDump          ' to store the current crash dump setting value
    Dim strReply              ' to store the user reply
    Dim strHostName           ' to store the host name
    Dim intMaxSizeUB          ' to store the upper bound for maximum size
    Dim i                     ' Loop variable

    ' variables used only if * is specified
    Dim objEnumerator         ' collection object for query results

    i = 0
    intFreeSpace      = 0
    intFreeDiskSpace  = 0
    intCurrentSize    = 0
    intMaxSizeUB      = 0
'    intIntSize        = CLng(intIntSize)
'    intMaxSize        = CLng(intMaxSize)
    blnSuccessMsg     = FALSE

    If NOT component.wmiConnect(CONST_NAMESPACE_CIMV2 , _
                      strUserName , _
                      strPassword , _
                      strMachine  , _
                      blnLocalConnection , _
                      objService  ) Then
        WScript.Echo(L_HintCheckConnection_Message)
        WScript.Quit(EXIT_METHOD_FAIL)
    End If

    If (objVols.Exists("*")) Then
        ' build the query
        intVolumes = 0
        ' get all the drive names with drive type = 3 (other than floppy drive & CDROM Drive)
        strQuery = "Select DeviceID From " & CLASS_LOGICAL_DISK & _
        " where DriveType = " & DRIVE_TYPE
        ' execute the query
        Set objEnumerator = objService.ExecQuery(strQuery, "WQL", 48, null)
        ' check for any errors
        If Err.Number Then
            Err.Clear
            WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
            WScript.Quit(EXIT_QUERY_FAIL)
        End If

        For each objInstance in objEnumerator
            ' check if the volumename is not an alias name and neither a mapped drive.
            If IsValidPhysicalDrive(objService, objInstance.DeviceID) Then
                ' check if the volume name is specified more than once.
                If NOT objVols.Exists(LCase(objInstance.DeviceID)) Then
                    objVols.Add LCase(objInstance.DeviceID),-1
                End If
            End If
        Next
        ' Remove * from objVols after adding the drives to the object.
        objVols.Remove "*"
    End If

    intVolumes = objVols.Count
    arrVolume  = objVols.Keys

    ' Get the host Name - used to get Crash Dump Settings
    strQueryComp = "Select * From " & CLASS_COMPUTER_SYSTEM
    Set objEnum = objService.ExecQuery(strQueryComp, "WQL", 0, null)
    ' check for any errors
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    For each objInst in objEnum
        If NOT ISEmpty(objInst.Name) Then
            strHostName = objInst.Name
        Else
            WSCript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
            WScript.Quit(EXIT_QUERY_FAIL)
        End If
    Next

    ' No wild Cards Specified
    Do While( i < intVolumes )

        strQueryDisk = "Select * From " & CLASS_LOGICAL_DISK & _
        " where DriveType = " & DRIVE_TYPE & " and DeviceID = '" & arrVolume(i) & "'"
        Set objEnumforDisk = objService.ExecQuery(strQueryDisk, "WQL", 0, null)

        strQuery = "Select * From " & CLASS_PAGE_FILE_SETTING & _
        " where Name = '" & arrVolume(i) & "\" & PAGEFILE_DOT_SYS & "'"
        Set objEnum = objService.ExecQuery(strQuery, "WQL", 0, null)

        ' If valid drive and pagefile exists on that drive
        If (objEnumforDisk.Count = 0 AND objEnum.Count = 0 ) Then
            ' the drive does not exist
            component.VBPrintf L_InvalidVolumeName_ErrorMessage, _
            Array(UCase(arrVolume(i)))
            ' remove the drive name from the valid drives list
            objVols.Remove arrVolume(i)
            ' decrement the loop count
            i = i - 1
            ' check for the no.of valid drive names from the specified list.
            If Cint(objVols.Count) = 0 Then
                WScript.Quit(EXIT_INVALID_INPUT)
            Else
                intVolumes = objVols.Count
                arrVolume  = objVols.keys
            End If
        Else
            ' SKIP - if at least one instance is found then dont create a new instance
            If (objEnumforDisk.Count = 1 AND objEnum.Count = 1) Then
                component.VBPrintf L_CreateSkipping_Message, _
                Array(UCase(arrVolume(i)))
            Else
                ' check if the volumename is an alias name or a mapped drive
                If NOT IsValidPhysicalDrive(objService, arrVolume(i)) Then
                    component.VBPrintf L_InvalidPhysicalDrive_ErrorMessage, _
                    Array(UCase(arrVolume(i)))
                Else
                    ' set the security privilege to allow pagefile creation
                    objService.Security_.Privileges.AddAsString("SeCreatePagefilePrivilege")
                    If Err.Number then
                        Err.Clear
                        WScript.Echo("ERROR: Failed to set the security privilege.")
                        WScript.Quit(EXIT_METHOD_FAIL)
                    End If

                    Set objInstance = objService.Get(CLASS_PAGE_FILE_SETTING)
                    ' check for any errors
                    If Err.Number Then
                        Err.Clear
                        WScript.Echo(L_CannotCreate_ErrorMessage)
                        WScript.Quit(EXIT_METHOD_FAIL)
                    End If

                    Set objNewInstance = objInstance.SpawnInstance_
                    ' check for any errors
                    If Err.Number Then
                        Err.Clear
                        WScript.Echo(L_CannotCreate_ErrorMessage)
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                    ' append the filename to the volume name
                    objNewInstance.Name = UCase(arrVolume(i)) & PAGEFILE_DOT_SYS

                    ' check if maxsize is greater than initsize
                    ' this will detect any overflow problems, if any
                    If ( CLng(intIntSize) > CLng(intMaxSize) ) Then
                        ' check for overflows and clear the error
                        If Err.Number Then Err.Clear
                        ' get the upper bound allowed for maximum size
                        intMaxSizeUB = getMaxSizeUB(objService)
                        component.VBPrintf InsufficientMaxSizeErrorMessage, _
                        Array( UCase(arrVolume(i)) , intMaxSizeUB )
                        WScript.Quit(EXIT_INVALID_INPUT)
                    End If

                    ' Check the initial size with the free space on the disk
                    If CLng(intIntSize) >= CLng(INITIAL_SIZE_LB) Then
                        ' check for overflows
                        If Err.Number Then
                            Err.Clear
                            WScript.Echo(L_InvalidInput_ErrorMessage)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        End If
                        ' get the free space on the specified disk
                        intFreeDiskSpace = getFreeSpaceOnDisk(arrVolume(i),objService)
                        ' get the current pagefile size
                        intCurrentSize = getCurrentPageFileSize(objService,objInstance)
                        ' get the total free space
                        '     Since its a new instance the current size will
                        '     NOT be available. So the initial size is taken 
                        '     into considerarion for calculating the total 
                        '     free space.
                        intFreeSpace = intFreeDiskSpace + intIntSize

                        ' Check if it greater than free disk space
                        If CLng(intIntSize) > CLng(intFreeSpace) Then
                            ' check for overflows
                            If Err.Number Then
                                Err.Clear
                                WScript.Echo(L_InvalidInput_ErrorMessage)
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If
                            WScript.Echo(NotEnoughSpaceErrorMessage)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        End If

                        If CLng(intIntSize) > CLng(intFreeSpace) - 5 Then
                            ' check for overflows
                            If Err.Number Then
                                Err.Clear
                                WScript.Echo(L_InvalidInput_ErrorMessage)
                                WScript.Quit(EXIT_INVALID_INPUT)
                            End If
                            WScript.Echo(AtLeastFiveMBErrorMessage)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        End If

                        ' get the crash dump setting value
                        intCrashDump = GetCrashDumpSetting(strUserName,strPassword,strMachine)
                        ' get the Physical Memory Size
                        intMemSize = GetPhysicalMemorySize(strHostName,objService)
                        ' check if the user has selected "yes" for the warning message
                        If isCrashDumpValueSet(intCrashDump,intIntSize,intMemSize,arrVolume(i)) Then
                            objNewInstance.InitialSize = CInt(intIntSize)
                            ' Get the Disk Size for the specified drive
                            intDiskSize = GetDiskSize(arrVolume(i),objService)
                            If (CLng(intMaxSize) > CLng(intDiskSize)) Then
                                ' check for overflows
                                If Err.Number Then
                                    Err.Clear
                                    ' get the upper bound allowed for maximum size
                                    intMaxSizeUB = getMaxSizeUB(objService)
                                    component.VBPrintf InsufficientMaxSizeErrorMessage, _
                                    Array( UCase(arrVolume(i)) , intMaxSizeUB )
                                    WScript.Quit(EXIT_INVALID_INPUT)
                                End If
                                component.VBPrintf DiskTooSmallErrorMessage, _
                                Array(UCase(arrVolume(i)))
                            Else
                                If (CLng(intMaxSize) > CLng(intFreeSpace)) Then
                                    ' check for overflows
                                    If Err.Number Then
                                        Err.Clear
                                        WScript.Echo(L_InvalidInput_ErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If
                                    component.VBPrintf GrowsToFreeSpaceWarningMessage, _
                                    Array(UCase(arrVolume(i)),intFreeSpace)
                                    strReply = getReply()
                                    If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                                        ' maxsize can grow only to the free disk space available.
                                        ' set the maxsize to the free space on disk.
                                        intMaxSize = intFreeSpace
                                        objNewInstance.MaximumSize = intMaxSize
                                        objNewInstance.Put_(CONST_WBEM_FLAG)
                                        If Err.Number Then
                                            Err.Clear
                                            WScript.Echo(L_CannotCreate_ErrorMessage)
                                            WScript.Quit(EXIT_INVALID_INPUT)
                                        End If
                                        component.VBPrintf CreateSuccessMessage, _
                                        Array(CInt(intIntSize),CInt(intMaxSize),UCase(arrVolume(i)))
                                        blnSuccessMsg = TRUE
                                    ElseIf LCase(strReply) = L_UserReplyNo_Text Then
                                        WScript.Quit(EXIT_SUCCESS)
                                    Else
                                        WScript.Echo(L_InvalidInput_ErrorMessage)
                                        WScript.Quit (EXIT_INVALID_INPUT)
                                    End If
                                Else
                                    objNewInstance.MaximumSize = CInt(intMaxSize)
                                    objNewInstance.Put_(CONST_WBEM_FLAG)
                                    If Err.Number Then
                                        Err.Clear
                                        WScript.Echo(L_CannotCreate_ErrorMessage)
                                        WScript.Quit(EXIT_INVALID_INPUT)
                                    End If
                                    component.VBPrintf CreateSuccessMessage, _
                                    Array(CInt(intIntSize),CInt(intMaxSize),UCase(arrVolume(i)))
                                    blnSuccessMsg = TRUE
                                End If
                            End If
                        End If
                    Else
                        ' get the upper bound allowed for maximum size
                        intMaxSizeUB = getMaxSizeUB(objService)
                        component.VBPrintf InitialSizeRangeErrorMessage, Array(intMaxSizeUB)
                    End If
                End If
            End If
        End If
        i = i + 1
    Loop

    If blnSuccessMsg = TRUE then
        WScript.Echo L_RestartComputer_Message
    End If

End Sub

'******************************************************************************
'* Sub:     ProcessDelete
'*
'* Purpose: Deletes existing page files on the specified volumes
'*
'* Input:
'*  [in]    strMachine         machine to configure page files on
'*  [in]    strUserName        user name to connect to the machine
'*  [in]    strPassword        password for the user
'*  [in]    objVols            the object containing volume names
'*
'* Output:  Displays error message and quits if connection fails
'*
'******************************************************************************
Private Sub ProcessDelete ( ByVal strMachine,  _
                            ByVal strUserName, _
                            ByVal strPassword, _
                            ByVal objVols      )
    ON ERROR RESUME NEXT
    Err.Clear

    Dim arrVolume             ' to store all the volumes specified
    Dim intVolumes            ' to store the no.of volumes specified
    Dim objService            ' service object
    Dim objInstance           ' instance object
    Dim blnSuccessMsg         ' flag to check if a SUCCESS message is generated
    Dim strQueryDisk          ' to store the query for disk
    Dim objEnumforDisk        ' collection object for query results
    Dim intMemSize            ' to store physical memory size
    Dim intCrashDump          ' to store the current crash dump setting value
    Dim strQueryComp          ' to store the query for computersystem
    Dim objEnum               ' collection object for query results
    Dim objInst               ' instance object
    Dim strHostName           ' to store the host name
    Dim i                     ' Loop variable

    If NOT component.wmiConnect(CONST_NAMESPACE_CIMV2 , _
                          strUserName , _
                          strPassword , _
                          strMachine  , _
                          blnLocalConnection , _
                          objService  ) Then
            WScript.Echo(L_HintCheckConnection_Message)
            WScript.Quit(EXIT_METHOD_FAIL)
    End If

    i = 0
    blnSuccessMsg = FALSE
    intVolumes    = objVols.Count
    arrVolume     = objVols.Keys

    ' Get the host Name - used to get Crash Dump Settings
    strQueryComp = "Select * From " & CLASS_COMPUTER_SYSTEM
    Set objEnum = objService.ExecQuery(strQueryComp, "WQL", 0, null)
    ' check for any errors
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    For each objInst in objEnum
        If NOT ISEmpty(objInst.Name) Then
            strHostName = objInst.Name
        Else
            WSCript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
            WScript.Quit(EXIT_QUERY_FAIL)
        End If
    Next

    Do While( i < intVolumes )
        strQueryDisk = "Select * From " & CLASS_LOGICAL_DISK & _
        " where DriveType = " & DRIVE_TYPE & " and DeviceID = '" & arrVolume(i) & "'"
        Set objEnumforDisk = objService.ExecQuery(strQueryDisk, "WQL", 0, null)
        If objEnumforDisk.Count > 0 Then
            Set objInstance = objService.Get(CLASS_PAGE_FILE_SETTING & "='" & _
            arrVolume(i) & PAGEFILE_DOT_SYS & "'")
            If Err.Number Then
                Err.Clear
                component.VBPrintf L_PageFileDoesNotExist_ErrorMessage, _
                Array(UCase(arrVolume(i)))
            Else
                ' check for system managed pagefiles
                If (objInstance.InitialSize = 0 AND objInstance.MaximumSize = 0) Then
                    component.VBPrintf L_SystemManagedSize_ErrorMessage, _
                    Array(UCase(arrVolume(i)))
                Else
                    ' get the crash dump setting value
                    intCrashDump = GetCrashDumpSetting(strUserName,strPassword,strMachine)
                    ' get the Physical Memory Size
                    intMemSize = GetPhysicalMemorySize(strHostName,objService)
                    ' If the user has selected "yes" for the warning message
                    ' pass initsize as 0 because initsize = maxsize = 0 (assumed) after deletion
                    If isCrashDumpValueSet(intCrashDump,0,intMemSize,arrVolume(i)) Then
                        ' Delete the instance
                        objInstance.Delete_
                        ' check for any errors
                        If Err.Number Then
                            Err.Clear
                            WScript.Echo(L_InvalidInput_ErrorMessage)
                            WScript.Quit(EXIT_INVALID_INPUT)
                        End If

                        component.VBPrintf L_DeleteSuccess_Message, _
                        Array(UCase(arrVolume(i)))
                        blnSuccessMsg = TRUE
                    End If
                End If
            End If
        Else
            ' the drive does not exist
            component.VBPrintf L_InvalidVolumeName_ErrorMessage, _
            Array(UCase(arrVolume(i)))
            ' remove the drive name from the valid drives list
            objVols.Remove arrVolume(i)
            ' decrement the loop count
            i = i - 1
            ' check for the no.of valid drive names from the specified list.
            If Cint(objVols.Count) = 0 Then
                WScript.Quit(EXIT_INVALID_INPUT)
            Else
                intVolumes = objVols.Count
                arrVolume  = objVols.keys
            End If
        End If
        i = i + 1
    Loop

' The instances of the following classes are also deleted along with the Win32_PageFile instances
' Win32_PageFileUsage - instances are deleted only after reboot
' Win32_PageFileSetting - instances are deleted automatically along with Win32_PageFile instances

    If blnSuccessMsg = TRUE then
        WScript.Echo L_RestartComputer_Message
    End If

End sub

'******************************************************************************
'* Sub:     ProcessQuery
'*
'* Purpose: Displays the Page File Details in the specified format
'*
'* Input:
'*  [in]    strMachine         machine to configure page files on
'*  [in]    strUserName        user name to connect to the machine
'*  [in]    strPassword        password for the user
'*  [in]    strFormat          the query display format
'*
'* Output:  Displays error message and quits if connection fails
'*          Calls component.showResults() to display the page file
'*          details
'*
'******************************************************************************
Private Sub ProcessQuery(   ByVal strMachine,  _
                            ByVal strUserName, _
                            ByVal strPassword, _
                            ByVal strFormat    )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objEnumerator            ' to store the results of the query is executed
    Dim objInstance              ' to refer to the instances of the objEnumerator
    Dim strQuery                 ' to store the query obtained for given conditions
    Dim intTotSize               ' to store the total size on all drives
    Dim intRecommendedSize       ' to store the recommended size for all drives
    Dim arrResultsDrives         ' to store the columns of page file info.
    Dim arrHeaderDrives          ' to store the array header values
    Dim arrMaxLengthDrives       ' to store the maximum length for each column
    Dim arrFinalResultsDrives    ' used to send the arrResults to ShowResults()
    Dim intColumnCountDrives     ' number of columns to be displayed in the output
    Dim blnPrintHeaderDrives     ' variable which decides whether header is to be displayed or not
    Dim arrResultsSummary        ' to store the columns of page file info.
    Dim arrHeaderSummary         ' to store the array header values
    Dim arrMaxLengthSummary      ' to store the maximum length for each column
    Dim arrFinalResultsSummary   ' used to send the arrResults to ShowResults()
    Dim intColumnCountSummary    ' number of columns to be displayed in the output
    Dim blnPrintHeaderSummary    ' variable which decides whether header is to be displayed or not
    Dim objDiskDriveInstance     ' Instance for drive name
    Dim objMemSizeInstance       ' Instance for memory size
    Dim arrblnNoDisplayDrives    ' boolean variable for -noheader option
    Dim arrblnNoDisplaySummary   ' boolean variable for -noheader option
    Dim objService               ' service object
    Dim strDriveName             ' to store the drive name
    Dim objUsageInstance         ' Instance for PageFileUsage

    ' Initializing the blnPrintHeaders to true. Header should be printed by default
    blnPrintHeaderDrives = TRUE
    blnPrintHeaderSummary = TRUE
    intTotSize = 0

    If NOT component.wmiConnect(CONST_NAMESPACE_CIMV2 , _
                          strUserName , _
                          strPassword , _
                          strMachine  , _
                          blnLocalConnection , _
                          objService  ) Then
            WScript.Echo(L_HintCheckConnection_Message)
            WScript.Quit(EXIT_METHOD_FAIL)
    End If

    arrHeaderDrives = Array(L_ColHeaderHostname_Text   , L_ColHeaderDrive_Text, _
                            L_ColHeaderVolumeLabel_Text, L_ColHeaderFileName_Text, _
                            L_ColHeaderInitialSize_Text, L_ColHeaderMaximumSize_Text, _
                            L_ColHeaderCurrentSize_Text, L_ColHeaderFreeSpace_Text)

    arrHeaderSummary = Array(L_ColHeaderHostname_Text, L_ColHeaderTotalMinimumSize_Text, _
                             L_ColHeaderTotalRecommendedSize_Text, L_ColHeaderTotalSize_Text)

    ' Data Lengths  = (15,13,13,19,20,20,20,22)
    arrMaxLengthDrives  = Array(CONST_HOSTNAME_LENGTH, CONST_DRIVENAME_LENGTH, CONST_VOLLABEL_LENGTH, _
                                CONST_PAGEFILENAME_LENGTH, CONST_INTSIZE_LENGTH, CONST_MAXSIZE_LENGTH, _
                                CONST_CURRENTSIZE_LENGTH, CONST_FREESPACE_LENGTH)

    ' Data Lengths  = (15,33,37,40)
    arrMaxLengthSummary = Array(CONST_HOSTNAME_LENGTH,CONST_TOTALMINSIZE_LENGTH,_
                                CONST_TOTALRECSIZE_LENGTH,CONST_TOTALSIZE_LENGTH)

    arrblnNoDisplayDrives  = Array(0,0,0,0,0,0,0,0)
    arrblnNoDisplaySummary = Array(0,0,0,0)

    ' first initialize the array with N/A
    arrResultsDrives  = Array(L_Na_Text,L_Na_Text,L_Na_Text,L_Na_Text,L_Na_Text,L_Na_Text,_
                              L_Na_Text,L_Na_Text)
    arrResultsSummary = Array(L_Na_Text,L_Na_Text,L_Na_Text,L_Na_Text)

    ' build the query
    strQuery = "SELECT * FROM " & CLASS_PAGE_FILE_SETTING

    ' execute the query
    Set objEnumerator = objService.ExecQuery(strQuery, "WQL", 0, null)
    ' check for any errors
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    ' If no.of pagefile instances are 0 (zero)
    If (objEnumerator.Count = 0) Then
        WScript.Echo(L_NoPageFiles_Message)
        WScript.Quit(EXIT_UNEXPECTED)
    End If

    ReDim arrFinalResultsDrives(0)
    ReDim arrFinalResultsSummary(0)

    WScript.Echo("") ' Blank Line

    ' Loop through all the instances for the first report
    For each objInstance in objEnumerator

        If NOT IsEmpty(objInstance.Name) Then
            strDriveName = Mid(objInstance.Name,1,2)
        End If

        ' check if it is a valid physical drive
        If IsValidPhysicalDrive(objService,strDriveName) Then

            If IsEmpty(objInstance.Name) Then
                arrResultsDrives(1) = L_Na_Text
            Else
                strDriveName = Mid(objInstance.Name,1,2)
                arrResultsDrives(1) = UCase(strDriveName)
            End If

            ' to get the data from Win32_PageFileUsage
            Set objUsageInstance = objService.Get(CLASS_PAGE_FILE_USAGE & "='" & objInstance.Name & "'")

            ' to get the current size
            If Len(objUsageInstance.AllocatedBaseSize) = 0 Then
                arrResultsDrives(6) = L_Na_Text
            Else
                arrResultsDrives(6) = objUsageInstance.AllocatedBaseSize & MEGA_BYTES
                intTotSize = intTotSize + objUsageInstance.AllocatedBaseSize
            End If

            ' to get the data from Win32_LogicalDisk
            Set objDiskDriveInstance = objService.Get(CLASS_LOGICAL_DISK & "='" & strDriveName & "'")

            If Len(objDiskDriveInstance.VolumeName) = 0 Then
                arrResultsDrives(2) = L_Na_Text
            Else
                arrResultsDrives(2) = objDiskDriveInstance.VolumeName
            End If

            If Len(objDiskDriveInstance.SystemName) = 0 Then
                arrResultsDrives(0) = L_Na_Text
            Else
                arrResultsDrives(0) = objDiskDriveInstance.SystemName
                arrResultsSummary(0) = objDiskDriveInstance.SystemName
            End If

            If (objDiskDriveInstance.FreeSpace) Then
                arrResultsDrives(7) = Int(objDiskDriveInstance.FreeSpace/CONVERSION_FACTOR) + Int(objUsageInstance.AllocatedBaseSize) &_
                MEGA_BYTES
            Else
                arrResultsDrives(7) = L_Na_Text
            End If

            If IsEmpty(objInstance.Name) Then
                arrResultsDrives(3) = L_Na_Text
            Else
                arrResultsDrives(3) = objInstance.Name
            End If

            If objInstance.InitialSize Then
                arrResultsDrives(4) = objInstance.InitialSize & MEGA_BYTES
            Else
                arrResultsDrives(4) = L_Na_Text
            End If

            If objInstance.MaximumSize Then
                arrResultsDrives(5) = objInstance.MaximumSize & MEGA_BYTES
            Else
                arrResultsDrives(5) = L_Na_Text
            End If

            arrFinalResultsDrives(0) = arrResultsDrives

            Call component.showResults(arrHeaderDrives, arrFinalResultsDrives, arrMaxLengthDrives, _
                                       strFormat, blnPrintHeaderDrives, arrblnNoDisplayDrives)
            blnPrintHeaderDrives = FALSE

        End If

    Next
    WScript.Echo("")

    ' Display the summary report
    arrResultsSummary(1) = INITIAL_SIZE_LB & MEGA_BYTES
    Set objMemSizeInstance = objService.Get(CLASS_COMPUTER_SYSTEM & "='" & arrResultsDrives(0) & "'")
    If objMemSizeInstance.TotalPhysicalMemory Then
        intRecommendedSize = Int(Int(objMemSizeInstance.TotalPhysicalMemory/CONVERSION_FACTOR)* SIZE_FACTOR)
        arrResultsSummary(2) = intRecommendedSize & MEGA_BYTES
    Else
        arrResultsSummary(2) = L_Na_Text
    End If

    arrResultsSummary(3) = intTotSize & MEGA_BYTES
    arrFinalResultsSummary(0) = arrResultsSummary

    Call component.showResults(arrHeaderSummary, arrFinalResultsSummary, arrMaxLengthSummary, strFormat, _
                               blnPrintHeaderSummary,arrblnNoDisplaySummary)
    blnPrintHeaderSummary = FALSE

End Sub


'******************************************************************************
'* Function: IsValidPhysicalDrive
'*
'* Purpose:  To check if the specified drive is a valid physical drive.
'*           This check is done only for Win2K builds and NOT for Whistler Builds.
'*
'* Input:
'*  [in]     objServiceParam      service object to maintain wmi connection.
'*  [in]     strDriveName         drive name whose validity has to be checked.
'*
'* Output:   Returns TRUE or FALSE
'*             TRUE  - when the drive is a valid physical drive.
'*             FALSE - when the drive is not a valid physical drive.
'*
'******************************************************************************

Private Function IsValidPhysicalDrive ( ByVal objServiceParam, _
                                        ByVal strDriveName )

    ON ERROR RESUME NEXT
    Err.Clear

    CONST WIN2K_MAJOR_VERSION = 5000
    CONST WINXP_MAJOR_VERSION = 5001

    Dim strQuery            ' to store the query to be executed
    Dim objEnum             ' collection object
    Dim objInstance         ' instance object
    Dim strValidDrives      ' to store all valid physical drives
    Dim strVersion          ' to store the OS version
    Dim arrVersionElements  ' to store the OS version elements
    Dim CurrentMajorVersion ' the major version number

    strValidDrives = ""
    ' by default set it to true
    IsValidPhysicalDrive = TRUE

    strquery = "Select * From " & CLASS_OPERATING_SYSTEM
    set objEnum = objServiceParam.ExecQuery(strQuery,"WQL",48,null)

    For each objInstance in objEnum
        strVersion= objInstance.Version
    Next

    ' OS Version : 5.1.xxxx(Whistler), 5.0.xxxx(Win2K)
    arrVersionElements  = split(strVersion,".")
    ' converting to major version
    CurrentMajorVersion = arrVersionElements(0) * 1000 + arrVersionElements(1)

    ' Determine the OS Type
    ' If the OS is Whistler, then NO NEED to validate.
    ' If the OS is Win2K, then validate the drive name.
    If CInt(CurrentMajorVersion) < CInt(WINXP_MAJOR_VERSION) Then

        strQuery = "Select * From " & CLASS_PERFDISK_PHYSICAL_DISK
        Set objEnum = objServiceParam.ExecQuery(strQuery, "WQL", 0, null)

        For each objInstance in objEnum
            ' get all the instance except the last one
            If (objInstance.Name <> "_Total") Then
                strValidDrives = strValidDrives & " " & objInstance.Name
            End If
        Next

        ' check if the specified drive is present in the list of valid physical drives
        If Instr(strValidDrives, UCase(strDriveName)) = 0 Then
            IsValidPhysicalDrive = FALSE
        End If

    End If

End Function


'******************************************************************************
'* Function: getFreeSpaceOnDisk
'*
'* Purpose:  To get the Free Space for the Specified Disk
'*
'* Input:
'*  [in]     strDriveName         drive name whose free space is needed 
'*  [in]     objServiceParam      service object to maintain wmi connection
'*
'* Output:   Returns the free space (in MB) on the specified disk.
'*
'******************************************************************************

Private Function getFreeSpaceOnDisk(ByVal strDriveName, ByVal objServiceParam)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objValidDiskInst

    Set objValidDiskInst = objServiceParam.Get(CLASS_LOGICAL_DISK & "='" & strDriveName & "'")
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    getFreeSpaceOnDisk = Int(objValidDiskInst.FreeSpace/CONVERSION_FACTOR)

End Function


'******************************************************************************
'* Function: getCurrentPageFileSize
'*
'* Purpose:  To get the current pagefile size on the specified drive
'*
'* Input:
'*  [in]     objService       wbem service object
'*  [in]     objInstance      instance of win32_pagefilesetting
'*
'* Output:   current pagefile size
'*
'******************************************************************************

Private Function getCurrentPageFileSize(ByVal objService, ByVal objInstance)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objUsageInstance

    ' get the data from Win32_PageFileUsage
    Set objUsageInstance = objService.Get(CLASS_PAGE_FILE_USAGE & "='" & objInstance.Name & "'")

    ' return the current size ( allocated base size )
    getCurrentPageFileSize = objUsageInstance.AllocatedBaseSize

End Function


'******************************************************************************
'* Function: GetDiskSize
'*
'* Purpose:  To get the disk size for the specified drive
'*
'* Input:
'*  [in]     strDriveName         drive name whose free space is needed
'*  [in]     objServiceParam      service object to maintain wmi connection
'*
'* Output:   Returns the total disk size in MB.
'*
'******************************************************************************

Private Function GetDiskSize(ByVal strDriveName, ByVal objServiceParam)

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objValidDiskInst      ' object to store valid disk name 

    Set objValidDiskInst = objServiceParam.Get(CLASS_LOGICAL_DISK & "='" & strDriveName & "'")

    If Err.Number Then
        Err.Clear
        WScript.Echo(L_UnableToRetrieveInfo_ErrorMessage)
        WScript.Quit(EXIT_QUERY_FAIL)
    End If

    GetDiskSize = Int(objValidDiskInst.Size / CONVERSION_FACTOR)

End Function


'******************************************************************************
'* Function: GetPhysicalMemorySize
'*
'* Purpose:  To get the physical memory size.
'*
'* Input:
'*  [in]     strHostName              host name to connect to
'*  [in]     objServiceParam          service object to maintain wmi connection
'*
'* Output:   Returns the physical memory size in MB.
'*
'******************************************************************************

Private Function GetPhysicalMemorySize( ByVal strHostName, ByVal objServiceParam )

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objMemSizeInstance          ' to store memory size
    Dim intReturnValue              ' to store return value

    Set objMemSizeInstance = objServiceParam.Get(CLASS_COMPUTER_SYSTEM & "='" & strHostName & "'")
    If Err.Number Then
        Err.Clear
        WScript.Echo L_UnableToRetrieveInfo_ErrorMessage
        WScript.Quit EXIT_QUERY_FAIL
    End If

    If objMemSizeInstance.TotalPhysicalMemory Then
        intReturnValue = Int(objMemSizeInstance.TotalPhysicalMemory/CONVERSION_FACTOR)
        GetPhysicalMemorySize = intReturnValue
    End If

End Function


'******************************************************************************
'* Function: getMaxSizeUB
'*
'* Purpose:  To get the allowed upper bound for maximum size
'*
'* Input:
'*  [in]     objServiceParam          service object to maintain wmi connection
'*
'* Output:   Returns the upper bound for maximum size
'*
'******************************************************************************

Private Function getMaxSizeUB(objServiceParam)

    ON ERROR RESUME NEXT
    Err.Clear

    CONST PROCESSOR_X86_BASED  = "X86"
    CONST PROCESSOR_IA64_BASED = "IA64"

    Dim objInstance         ' object instance
    Dim intReturnValue      ' to store return value
    Dim strProcessorType    ' to store the processor type
    Dim strQuery            ' to store the query
    Dim objEnum             ' collection of objects

    getMaxSizeUB     = 0

    strQuery = "Select * From " & CLASS_COMPUTER_SYSTEM

    Set objEnum = objServiceParam.ExecQuery(strQuery,"WQL",48,null)
    If Err.Number Then
        Err.Clear
        WScript.Echo L_UnableToRetrieveInfo_ErrorMessage
        WScript.Quit EXIT_QUERY_FAIL
    End If

    ' The following code will handle only single processor environment

    For each objInstance in objEnum
        strProcessorType = objInstance.SystemType
    Next

    ' check if its a 32-bit processor
    If InStr( UCase(strProcessorType),PROCESSOR_X86_BASED ) > 0 Then
        getMaxSizeUB = 4096
    End If

    ' check if its a 64-bit processor
    If Instr( UCase(strProcessorType),PROCESSOR_IA64_BASED ) > 0 Then
        getMaxSizeUB = 33554432
    End If

End Function

'******************************************************************************
'* Function: GetCrashDumpSetting
'*
'* Purpose:  To get the Crash Dump Settings for the machine specified
'*
'* Input:
'*  [in]    strUserNameParam        user name to connect to the machine
'*  [in]    strPasswordParam        password for the user
'*  [in]    strMachineParam         machine to get crash dump settings for
'*
'* Output:  Returns the current crash dump setting value [ 0,1,2,3 ]
'*            0 - None
'*            1 - Complete Memory Dump
'*            2 - Kernel Memory Dump
'*            3 - Small Memory Dump
'*
'******************************************************************************

Private Function GetCrashDumpSetting( ByVal strUserNameParam, _
                                      ByVal strPasswordParam, _
                                      ByVal strMachineParam   )

    ON ERROR RESUME NEXT
    Err.Clear

    CONST CONST_NAMESPACE_DEFAULT     = "root\default"      ' name space to connect to
    CONST CONST_HKEY_LOCAL_MACHINE    = 2147483650          ' registry value for HKEY_LOCAL_MACHINE
    CONST CONST_KEY_VALUE_NAME        = "CrashDumpEnabled"  ' value name to be retrieved
    CONST CONST_STD_REGISTRY_PROVIDER = "StdRegProv"        ' standard registry provider
    ' the Sub Key Name
    CONST CONST_CRASH_DUMP_REGKEY     = "SYSTEM\CurrentControlSet\Control\CrashControl"

    Dim objInstance          ' to store the object instance
    Dim objService           ' service object
    Dim intCrashDumpValue    ' to store the crash dump setting value
    Dim intReturnVal         ' to store return value

    ' connect to the name space
    If NOT component.wmiConnect(CONST_NAMESPACE_DEFAULT , _
                      strUserNameParam   , _
                      strPasswordParam   , _
                      strMachineParam    , _
                      blnLocalConnection , _
                      objService  ) Then
        WScript.Echo(L_HintCheckConnection_Message)
        WScript.Quit(EXIT_METHOD_FAIL)
    End If

    ' get the instance of the Standard Registry Provider
    Set objInstance = objService.Get(CONST_STD_REGISTRY_PROVIDER)

    ' get the key value for from the registry
    intReturnVal = objInstance.GetDWORDValue( CONST_HKEY_LOCAL_MACHINE, _
                                              CONST_CRASH_DUMP_REGKEY, _
                                              CONST_KEY_VALUE_NAME, _
                                              intCrashDumpValue )
    ' check if any error has occured
    If Err.Number <> 0 Then
        Err.Clear
        WScript.Echo(L_FailCreateObject_ErrorMessage)
        WScript.Quit(EXIT_INVALID_PARAM)
    End If

    ' check for the return value after registry is accessed.
    If intReturnVal = 0 Then
        GetCrashDumpSetting = CInt(intCrashDumpValue)
    Else
        WScript.Echo(L_FailCreateObject_ErrorMessage)
        WScript.Quit(EXIT_INVALID_PARAM)
    End If

End Function


' Function used to get the reply in y/n from the user
'******************************************************************************
'* Function: getReply
'*
'* Purpose:  To get reply from the user
'*
'* Input:    None
'*
'* Output:   Prompts for a warning message and accepts the user's choice [y/n]
'*           
'******************************************************************************
Private Function getReply()

    ON ERROR RESUME NEXT
    Err.Clear

    Dim objStdIn     ' to store value from standard input
    Dim strReply     ' to store the user reply

    WScript.Echo(L_PromptForContinueAnyWay_Message)

    Set objStdIn = WScript.StdIn
    
    If Err.Number Then
        Err.Clear
        WScript.Echo(L_FailCreateObject_ErrorMessage)
        WScript.Quit(EXIT_INVALID_PARAM)
    End If

    strReply = objStdIn.ReadLine()
    getReply = Trim(strReply)

End Function


'******************************************************************************
'* Function: isCrashDumpValueSet
'*
'* Purpose:  To check if the crash dump value is set
'*
'* Input:
'*  [in]     intCrashDumpParam       crash dump setting value
'*  [in]     intIntSizeParam         initial size of the pagefile
'*  [in]     intMemSizeParam         physical memory size
'*  [in]     strVolume               drive/volume name
'*
'* Output:   Returns TRUE or FALSE
'*
'******************************************************************************

Private Function isCrashDumpValueSet( ByVal intCrashDumpParam,_
                                      ByVal intIntSizeParam,  _
                                      ByVal intMemSizeParam,  _
                                      ByVal strVolume )

    ON ERROR RESUME NEXT
    Err.Clear

    ' Constants for Crash Dump Settings
    CONST NO_MEMORY_DUMP       = 0
    CONST COMPLETE_MEMORY_DUMP = 1
    CONST KERNEL_MEMORY_DUMP   = 2
    CONST SMALL_MEMORY_DUMP    = 3

    Dim strReply        ' to store user reply
    Dim intSizeValue    ' to store the size value used for comparison

    ' default value is NO [n]
    strReply = L_UserReplyNo_Text

    Select Case CInt(intCrashDumpParam)

        Case COMPLETE_MEMORY_DUMP
            If CInt(intIntSizeParam) < CInt(intMemSizeParam) Then
                component.VBPrintf CrashDumpSettingWarningMessage, Array(UCase(strVolume),CInt(intMemSizeParam) & MEGA_BYTES)
                ' Ask for choice until a yes[y] or no[n] is given
                Do
                    strReply = getReply()
                    If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                        isCrashDumpValueSet = TRUE
                    ElseIf Trim(LCase(strReply)) = L_UserReplyNo_Text Then
                        isCrashDumpValueSet = FALSE
                    Else
                        WScript.Echo(L_InvalidUserReply_ErrorMessage)
                    End If
                Loop Until (Trim(LCase(strReply)) = L_UserReplyYes_Text OR Trim(LCase(strReply)) = L_UserReplyNo_Text)
            Else
                isCrashDumpValueSet = TRUE
            End If

        Case KERNEL_MEMORY_DUMP

            ' check if RAM size is less than or equal to 128 MB
            If CInt(intMemSizeParam) <= 128 Then
                ' assign size value to be checked to 50 MB
                intSizeValue = 50
            Else
                ' check if RAM size is less than or equal to 4 GB
                If CInt(intMemSizeParam) <= 4096 Then
                    ' assign size value to be checked to 200 MB
                    intSizeValue = 200
                Else
                    ' check if RAM size is less than or equal to 8 GB
                    If CInt(intMemSizeParam) <= 8192 Then
                        ' assign size value to be checked to 400 MB
                        intSizeValue = 400
                    Else
                        ' assign size value to be checked to 800 MB
                        intSizeValue = 800
                    End If
                End If
            End If

            If CInt(intIntSizeParam) < CInt(intSizeValue) Then
                component.VBPrintf CrashDumpSettingWarningMessage, Array(UCase(strVolume),intSizeValue & MEGA_BYTES)
                ' Ask for choice until a yes[y] or no[n] is given
                Do
                    strReply = getReply()
                    If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                        isCrashDumpValueSet = TRUE
                    ElseIf Trim(LCase(strReply)) = L_UserReplyNo_Text Then
                        isCrashDumpValueSet = FALSE
                    Else
                        WScript.Echo(L_InvalidUserReply_ErrorMessage)
                    End If
                Loop Until (Trim(LCase(strReply)) = L_UserReplyYes_Text OR Trim(LCase(strReply)) = L_UserReplyNo_Text)
            Else
                isCrashDumpValueSet = TRUE
            End If

        Case SMALL_MEMORY_DUMP

            ' initial size should not be less than 64 KB ( less than or equal to 0 MB )
            If CInt(intIntSizeParam) <= 0 Then
                component.VBPrintf CrashDumpSettingWarningMessage, Array(UCase(strVolume),"64 KB")
                ' Ask for choice until a yes[y] or no[n] is given
                Do
                    strReply = getReply()
                    If Trim(LCase(strReply)) = L_UserReplyYes_Text Then
                        isCrashDumpValueSet = TRUE
                    ElseIf Trim(LCase(strReply)) = L_UserReplyNo_Text Then
                        isCrashDumpValueSet = FALSE
                    Else
                        WScript.Echo(L_InvalidUserReply_ErrorMessage)
                    End If
                Loop Until (Trim(LCase(strReply)) = L_UserReplyYes_Text OR Trim(LCase(strReply)) = L_UserReplyNo_Text)
            Else
                isCrashDumpValueSet = TRUE
            End If

        Case NO_MEMORY_DUMP

            ' Crash Dump values 0 has no problem
            isCrashDumpValueSet = TRUE

    End Select

End Function


'******************************************************************************
'* Sub:     typeMessage
'*
'* Purpose: To print the type usage messages relevent to the main option 
'*          selected.
'*
'* Input:   The main option selected.
'*
'* Output:  Prints "type..usage" messages for the main option selected.
'*
'******************************************************************************

Sub typeMessage(ByVal intMainOption)

    ON ERROR RESUME NEXT
    Err.Clear

    Select Case CInt(intMainOption)

        Case CONST_CHANGE_OPTION
            component.VBPrintf L_TypeChangeUsage_Message,Array(UCase(WScript.ScriptName))
        Case CONST_CREATE_OPTION
            component.VBPrintf L_TypeCreateUsage_Message,Array(UCase(WScript.ScriptName))
        Case CONST_DELETE_OPTION
            component.VBPrintf L_TypeDeleteUsage_Message,Array(UCase(WScript.ScriptName))
        Case CONST_QUERY_OPTION
            component.VBPrintf L_TypeQueryUsage_Message,Array(UCase(WScript.ScriptName))
        Case Else
            component.VBPrintf L_TypeUsage_Message,Array(UCase(WScript.ScriptName))

    End Select

End Sub


'******************************************************************************
'* Sub:     ShowUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages are displayed on screen.
'*
'******************************************************************************
Sub ShowUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowUsageLine02_Text )              ' Line 2
    WScript.Echo vbCr                                   ' Line 3
    WScript.Echo( L_UsageDescription_Text )             ' Line 4
    WScript.Echo( L_ShowUsageLine05_Text )              ' Line 5
    WScript.Echo( L_ShowUsageLine06_Text )              ' Line 6
    WScript.Echo vbCr                                   ' Line 7
    WScript.Echo( L_ShowUsageLine08_Text )              ' Line 8
    WScript.Echo( L_ShowUsageLine09_Text )              ' Line 9
    WScript.Echo( L_ShowUsageLine10_Text )              ' Line 10
    WScript.Echo vbCr                                   ' Line 11
    WScript.Echo( L_ShowUsageLine12_Text )              ' Line 12
    WScript.Echo vbCr                                   ' Line 13
    WScript.Echo( L_ShowUsageLine14_Text )              ' Line 14
    WScript.Echo vbCr                                   ' Line 15
    WScript.Echo( L_ShowUsageLine16_Text )              ' Line 16
    WScript.Echo( L_ShowUsageLine17_Text )              ' Line 17
    WScript.Echo vbCr                                   ' Line 18
    WScript.Echo( L_ShowUsageLine19_Text )              ' Line 19
    WScript.Echo( L_ShowUsageLine20_Text )              ' Line 20
    WScript.Echo( L_ShowUsageLine21_Text )              ' Line 21
    WScript.Echo( L_ShowUsageLine22_Text )              ' Line 22
    WScript.Echo( L_ShowUsageLine23_Text )              ' Line 23
    WScript.Echo( L_ShowUsageLine24_Text )              ' Line 24
    WScript.Echo( L_ShowUsageLine25_Text )              ' Line 25

End Sub


'******************************************************************************
'* Sub:     ShowChangeUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages for the /Change o ption are displayed on screen.
'*
'******************************************************************************
Sub ShowChangeUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowChangeUsageLine02_Text )        ' Line 2
    WScript.Echo( L_ShowChangeUsageLine03_Text )        ' Line 3
    WScript.Echo( L_ShowChangeUsageLine04_Text )        ' Line 4
    WScript.Echo vbCr                                   ' Line 5
    WScript.Echo( L_UsageDescription_Text )             ' Line 6
    WScript.Echo( L_ShowChangeUsageLine07_Text )        ' Line 7
    WScript.Echo vbCr                                   ' Line 8
    WScript.Echo( L_UsageParamList_Text )               ' Line 9
    WScript.Echo( L_UsageMachineName_Text )             ' Line 10
    WScript.Echo vbCr                                   ' Line 11
    WScript.Echo( L_UsageUserNameLine1_Text )           ' Line 12
    WScript.Echo( L_UsageUserNameLine2_Text )           ' Line 13
    WScript.Echo vbCr                                   ' Line 14
    WScript.Echo( L_UsagePasswordLine1_Text )           ' Line 15
    WScript.Echo( L_UsagePasswordLine2_Text )           ' Line 16
    WScript.Echo vbCr                                   ' Line 17
    WScript.Echo( L_ShowChangeUsageLine18_Text )        ' Line 18
    WScript.Echo( L_ShowChangeUsageLine19_Text )        ' Line 19
    WScript.Echo vbCr                                   ' Line 20
    WScript.Echo( L_ShowChangeUsageLine21_Text )        ' Line 21
    WScript.Echo( L_ShowChangeUsageLine22_Text )        ' Line 22
    WScript.Echo vbCr                                   ' Line 23
    WScript.Echo( L_ShowChangeUsageLine24_Text )        ' Line 24
    WScript.Echo( L_ShowChangeUsageLine25_Text )        ' Line 25
    WScript.Echo( L_ShowChangeUsageLine26_Text )        ' Line 26
    WScript.Echo( L_ShowChangeUsageLine27_Text )        ' Line 27
    WScript.Echo vbCr                                   ' Line 28
    WScript.Echo( L_UsageExamples_Text )                ' Line 29
    WScript.Echo( L_ShowChangeUsageLine30_Text )        ' Line 30
    WScript.Echo( L_ShowChangeUsageLine31_Text )        ' Line 31
    WScript.Echo( L_ShowChangeUsageLine32_Text )        ' Line 32
    WScript.Echo( L_ShowChangeUsageLine33_Text )        ' Line 33
    WScript.Echo( L_ShowChangeUsageLine34_Text )        ' Line 34
    WScript.Echo( L_ShowChangeUsageLine35_Text )        ' Line 35

End Sub


'******************************************************************************
'* Sub:     ShowCreateUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages for the /Create option are displayed on screen.
'*
'******************************************************************************
Sub ShowCreateUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowCreateUsageLine02_Text )        ' Line 2
    WScript.Echo( L_ShowCreateUsageLine03_Text )        ' Line 3
    WScript.Echo( L_ShowCreateUsageLine04_Text )        ' Line 4
    WScript.Echo vbCr                                   ' Line 5
    WScript.Echo( L_UsageDescription_Text )             ' Line 6
    WScript.Echo( L_ShowCreateUsageLine07_Text )        ' Line 7
    WScript.Echo vbCr                                   ' Line 8
    WScript.Echo( L_UsageParamList_Text )               ' Line 9
    WScript.Echo( L_UsageMachineName_Text )             ' Line 10
    WScript.Echo vbCr                                   ' Line 11
    WScript.Echo( L_UsageUserNameLine1_Text )           ' Line 12
    WScript.Echo( L_UsageUserNameLine2_Text )           ' Line 13
    WScript.Echo vbCr                                   ' Line 14
    WScript.Echo( L_UsagePasswordLine1_Text )           ' Line 15
    WScript.Echo( L_UsagePasswordLine2_Text )           ' Line 16
    WScript.Echo vbCr                                   ' Line 17
    WScript.Echo( L_ShowCreateUsageLine18_Text )        ' Line 18
    WScript.Echo( L_ShowCreateUsageLine19_Text )        ' Line 19
    WScript.Echo vbCr                                   ' Line 20
    WScript.Echo( L_ShowCreateUsageLine21_Text )        ' Line 21
    WScript.Echo( L_ShowCreateUsageLine22_Text )        ' Line 22
    WScript.Echo vbCr                                   ' Line 23
    WScript.Echo( L_ShowCreateUsageLine24_Text )        ' Line 24
    WScript.Echo( L_ShowCreateUsageLine25_Text )        ' Line 25
    WScript.Echo( L_ShowCreateUsageLine26_Text )        ' Line 26
    WScript.Echo( L_ShowCreateUsageLine27_Text )        ' Line 27
    WScript.Echo vbCr                                   ' Line 28
    WScript.Echo( L_UsageExamples_Text )                ' Line 29
    WScript.Echo( L_ShowCreateUsageLine30_Text )        ' Line 30
    WScript.Echo( L_ShowCreateUsageLine31_Text )        ' Line 31
    WScript.Echo( L_ShowCreateUsageLine32_Text )        ' Line 32
    WScript.Echo( L_ShowCreateUsageLine33_Text )        ' Line 33
    WScript.Echo( L_ShowCreateUsageLine34_Text )        ' Line 34
    WScript.Echo( L_ShowCreateUsageLine35_Text )        ' Line 35

End Sub


'******************************************************************************
'* Sub:     ShowDeleteUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages for the /Delete option are displayed on screen.
'*
'******************************************************************************
Sub ShowDeleteUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowDeleteUsageLine02_Text )        ' Line 2
    WScript.Echo( L_ShowDeleteUsageLine03_Text )        ' Line 3
    WScript.Echo vbCr                                   ' Line 4
    WScript.Echo( L_UsageDescription_Text )             ' Line 5
    WScript.Echo( L_ShowDeleteUsageLine06_Text )        ' Line 6
    WScript.Echo vbCr                                   ' Line 7
    WScript.Echo( L_UsageParamList_Text )               ' Line 8
    WScript.Echo( L_UsageMachineName_Text )             ' Line 9
    WScript.Echo vbCr                                   ' Line 10
    WScript.Echo( L_UsageUserNameLine1_Text )           ' Line 11
    WScript.Echo( L_UsageUserNameLine2_Text )           ' Line 12
    WScript.Echo vbCr                                   ' Line 13
    WScript.Echo( L_UsagePasswordLine1_Text )           ' Line 14
    WScript.Echo( L_UsagePasswordLine2_Text )           ' Line 15
    WScript.Echo vbCr                                   ' Line 16
    WScript.Echo( L_ShowDeleteUsageLine17_Text )        ' Line 17
    WScript.Echo( L_ShowDeleteUsageLine18_Text )        ' Line 18
    WScript.Echo( L_ShowDeleteUsageLine19_Text )        ' Line 19
    WScript.Echo vbCr                                   ' Line 20
    WScript.Echo( L_UsageExamples_Text )                ' Line 21
    WScript.Echo( L_ShowDeleteUsageLine22_Text )        ' Line 22
    WScript.Echo( L_ShowDeleteUsageLine23_Text )        ' Line 23
    WScript.Echo( L_ShowDeleteUsageLine24_Text )        ' Line 24
    WScript.Echo( L_ShowDeleteUsageLine25_Text )        ' Line 25

End Sub


'******************************************************************************
'* Sub:     ShowQueryUsage
'*
'* Purpose: Shows the correct usage to the user.
'*
'* Input:   None
'*
'* Output:  Help messages for the /Query option are displayed on screen.
'*
'******************************************************************************
Sub ShowQueryUsage()

    WScript.Echo vbCr                                   ' Line 1
    WScript.Echo( L_ShowQueryUsageLine02_Text )         ' Line 2
    WScript.Echo( L_ShowQueryUsageLine03_Text )         ' Line 3
    WScript.Echo vbCr                                   ' Line 4
    WScript.Echo( L_UsageDescription_Text )             ' Line 5
    WScript.Echo( L_ShowQueryUsageLine06_Text )         ' Line 6
    WScript.Echo vbCr                                   ' Line 7
    WScript.Echo( L_UsageParamList_Text )               ' Line 8
    WScript.Echo( L_UsageMachineName_Text )             ' Line 9
    WScript.Echo vbCr                                   ' Line 10
    WScript.Echo( L_UsageUserNameLine1_Text )           ' Line 11
    WScript.Echo( L_UsageUserNameLine2_Text )           ' Line 12
    WScript.Echo vbCr                                   ' Line 13
    WScript.Echo( L_UsagePasswordLine1_Text )           ' Line 14
    WScript.Echo( L_UsagePasswordLine2_Text )           ' Line 15
    WScript.Echo vbCr                                   ' Line 16
    WScript.Echo( L_ShowQueryUsageLine17_Text )         ' Line 17
    WScript.Echo( L_ShowQueryUsageLine18_Text )         ' Line 18
    WScript.Echo( L_ShowQueryUsageLine19_Text )         ' Line 19
    WScript.Echo vbCr                                   ' Line 20
    WScript.Echo( L_UsageExamples_Text )                ' Line 21
    WScript.Echo( L_ShowQueryUsageLine22_Text )         ' Line 22
    WScript.Echo( L_ShowQueryUsageLine23_Text )         ' Line 23
    WScript.Echo( L_ShowQueryUsageLine24_Text )         ' Line 24
    WScript.Echo( L_ShowQueryUsageLine25_Text )         ' Line 25
    WScript.Echo( L_ShowQueryUsageLine26_Text )         ' Line 26
    WScript.Echo( L_ShowQueryUsageLine27_Text )         ' Line 27

End Sub


'+----------------------------------------------------------------------------+
'|                            End of the Script                               |
'+----------------------------------------------------------------------------+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             _o_e_*h__Y_4__  QV3|_uNNNMFNNNh  N ElMF8   ^d    _h__g__o_e_*h__Y_4_UV39un  }_ _uDh   \_;Y_V  0_hL_h _ _    _YY3@^] 9u)  %_Uu   YH]U=_  h _h_u
   ]%_#   FM_^[d    UQQe MVEP3
|jEPh_uA   }  } t	u_^D i s a b l e T r a c i n g   UQVW}EPW3VVuE   u_
  _^ Vh  f3FF F$F_F,^ _h__[^__w__*h___Y_4_H_jPd    PD$d%    l$l$PD$L$L$u	D$ SD$d$D$[ =   s  PQL$   -   =   s+@PPPuEuPjujj
: zj h__Nu}VSW>VSWVSWVVSWVSW0VSW2VSWVSWVSW%  DisableTipPassThruCheck _S]u
W # VuWjY_3jj "YEe t< 3Mu SuV}VYeSVW	 FSVW	 6SVW &SVWZ	 SVWMR	 SVWh
 _^QQSVWNh  u9YE;E  
3f@,f;BQSVWu3}F f_  NSEf_F f_sF,e_~0~4~8S<@  ESFPE~~T@  X@  ~P_VEP_u3uX_3_3_3EP_E3E3%  ^u@  X_fe _8_3xYW5_QVh  Nub3S]u
W # VuWjYd_3j YMe t	 3Mu
 dSuV}VYGEVuuj PQEPQ^>Hub}=p-_fxpU  ;ebL=j ht_-_3_^ `_P_TCPNoDelay UEu
W   EVWjY_3uGjYt`  <_3   uuWAj 3jY0_3uCj@Yt`  _3tSuuWjjY_3uJjYt`  (_3u 6uuWj5 uuP} s_^s* `}jYl_3E  @ ?I_S]u
W $# } VWv}jY_3a&3 j _^EH}jY|_3uME  @ HPEHu5U_3@EH$3@UEV3+-D_VVj.hT_EEPjhr jjz 3|_tP_4_d:\xpsp\com\com1x\dtc\dtc\asc\ascmain.cpp jD_Pd_P`_QQSWh  ]Ph _h   h_=   v   _=_MemBufferSize DTCMemAlloc h   h(_V;
 d : \ x p s p \ c o m \ c o m 1 x \ d t c \ s h a r e d \ u t i l \ u t s e m . c p p   EU+@"Vu+Au^@u_^_=_DP4_\J  =_@_ (_j
 _95_~_3_;u _	;t_- _9 _sPh_5_=_ bWVSK3sWPSt	[WVSu!E} B_5WVSE(]%_uuuuw
 2~
%    +E!_8_3xYW5_,_8_3x5YW5_ C;~
%    Vh_jh  h_
 Failed to open the TRACE_REG_MISC_KEY key, hr=0x%1!x!
 h_jh-  h_FV
 The Tracing Feature has bee determined to have been disabled
 QSVWh  Nuh;F   D_Sh_jhx  h_
 QSVWh  Nu;F   D_Wh_jj'h,_w
 sdC2  QpdC2  QYB  qn  Q}WY _Z]9  Q qn  Q qn  Qk Oq(:  Qq(:  Q}< Anttl  h0[G  Q_*[G  Q@[G  Qag7C< An/; _ZpA E  Q                VL OjJH O>FH OzSHH On N OjJH OjJH Opb OgHO OA?0 `0AK `1G`v `E `E `E `E `d `_A__d:\xpsp\com\com1x\dtc\dtc\tm\src\cohelper.cpp i7_i7_i7____d:\xpsp\com\com1x\dtc\dtc\tm\src\tmassociate.cpp _}_9__d:\xpsp\com\com1x\dtc\dtc\tm\inc\TMJoiTem.H -_p_______X_#______$_D_9_9_____-_p_______X_#______$_D_9_9___/__-_p___V____X_#______$_D_W_9_____-_p_/__A____X_#______$_D__9_____i7_i7_i7_i7_i7_i7_i7_i7_i7_i7_i7__p_______X_#______$_D_l_9___/__-_p_______X_#______$_D_m_9_____-_p___A____X_#______$_D_9_9_____ _-_p_______X_#______$_D_9_9_____%_-_p_______X_#______$_D_8_9_____-_p_______X_#______$_D__9______p_______X_#______$_D_9_9_____t1_v_-_ _______X_#______$_D_9_9______p_______X_#______$_D_9_9_h_____s_s_s_s_
t_t_,t_=t_Nt__t__8_9_9_9_9_!_!_G:_`:_9_9_9_y:_;_9_"_;_"_<_'<_i7__s_s_s_s_
t_t_,t_=t_Nt__t__8_9_9_9_9_!_!_G:_`:_9_9_9_y:_;_9_"_;_"_<_'<_p_{WFso____[_\______8_9_9_____>__z_____8_9_9_____9_\_T_____8_9_9_____>_\_z_____8_9_9_____^_\_T_____8_9_9_d:\xpsp\com\com1x\dtc\dtc\tm\src\tmbegin.cpp __c}__}}_3_a_____________>_\_z_____8__9_____>_\_z_____8__9______\______(_9_9_i____>_\_z__*_v_v_8__9_____>_\_z_____8__9_____>_\_z__#_K_s___9_Not Found Description Not Specified _"_-_8__C_N_Y___!_____!_I_q______<_
____)_Q______C_9_____5_]______%_M_M_9_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k__}__%_M_M_9_9________h__9_!__h_f_M_!_I_q____\__<_____)_Q__ _T_O___9_____5_]__k____h_M_M_9_9__"_-_8__C_N_Y___!____M_________<_d_____Q_y_____C_9_____5_]______%_M_M_9_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M_9_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M_H_9__"_-_8__C_N_Y___!__h_f_M_!_I_q______<_____)_Q_y_ ____C_9_____5_]__k____h_X__z_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M_m_9________h__9_!__h__M_!_I_q___,___<_____)_Q___T_O___9_____5_]__k____h_M_M__9________h__9_!__h_f_M_!_I_q______<_____)_Q__ _T_O___9_____5_]__k____h_M_M__9___P_____h__9_!__h_f_M_!_I_q______<_____)_Q__ _T_O___9_____ ___k____h_M_M_4_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_ ____C_9_____5_]__k____%_M_M_9_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M_9_9__"_-_8__C_N_Y___!__h_f_M_!_I_q_______H____)_Q_y_ ____C_9__I ___5_]__k____h_ __9_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M_d_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M_9_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M_
_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M__9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M__9__"_-_8__C_N_Y___!__h__M_!_I_q______$__g___)__y_ ____C_9_____5_]__k____%_M_M_9_9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M__9__"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_K____C_9_____5_]__k____%_M_M_(_9_d:\xpsp\com\com1x\dtc\dtc\tm\src\tmbrod.cpp 8_h__g__o_e_*h__Y_4___h__g__o_e_*h__Y_4__h__g__o_e_*h__Y_4__h__g__o_e_*h__Y_4__h__g__o_e_*h__Y_4__h__g__o_e_*h__Y_4_"_h__g__o_e_*h__Y_4_I_h__g__o_e_*h__Y_4_:c__0__9_ _9_]_ _:c__0__9_'_9_]_ ____._%_?_Y______:c__0__9_N_9_]_ _n______:c__0__9_u_9_]_ _:c__0__9__9_]_ _:c__0__9__9_]_ _:c__0__9__9_]_ _:c__0__9__9_]_ __"_-_8__C_N_Y___!____M_!_I_q______<_d____)_Q_y_____C_9_____5_]__k____%_M_M__9_s_,_____&_K_e______F_`__z_____d:\xpsp\com\com1x\dtc\dtc\tm\src\tmchabor.cpp A__]_n_____8_`___T_______(_H_9_9_
_____8____T_______(_H_	_9_
_____8_`___T_______(_H_u_9_
_____8_`___T_______(_H_9_9_
_%_____A_`___T_______(_H_9_9_
______8_`___T_______(_H__9_
_____8_`___T_______(_H_u_9_
_____8____T_______(_H_9_9_
_t1_v__ ___8_`___T_______(_H_9_9_
_____8_`___T_______(_H_9_9_h___________8_`___T_______(_H_~_9_
_=F6e}^_______7_b___9__9_^_n_____$_7_b___9_9_9_^__~_____7_b___9_9_9_^_______7_b__$_9_K_9_^_____%__7_b___9_\_9_^_______7_b___9_"_9_^_______7_b___9__9_^_______7____9__9_^_______7____9_9_9_^_______7_b___9_Q%_9_^_______7_b___9_9_9_^_______7_b___9_$_9_^_7$_____w%_7_b___9_9_9_^_______7_b__w%_9_K_9_^_______7&_b___9_9_9________7_b___9_9_9_^____$___7_b___9__9_^___G____7_b___9_(_9_^_______7____G$___d:\xpsp\com\com1x\dtc\dtc\tm\src\tmcheckp.cpp __V__~__9__h_Ci__i_____9_^_______7_b___9_#_9__M_!_h_Ci_'_@_Z(_(_@_)_,)_O_R OR Og-_*_*_+_Z-_-_9_9_+_/_*_+_,_,_+_9_+_*_./_+_)+_Q+_9_9_d:\xpsp\com\com1x\dtc\dtc\tm\src\tmcpreslog.cpp |,_h_Ci__i_,_,_**_+_*_*_+_)+_Q+_+_9_._h_Ci__i_,_,_**_i7_i7_i7_i7_uGo? sPLqnld:\xpsp\com\com1x\dtc\dtc\tm\src\tmenlist.cpp :A_A_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_4_-4_U4_rL_4_4_5_15_O5_H_m5_5_9__5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_<>_9_i_v3_3_4_-4_U4_}4_M_4_5_15_O5_4_m5_5_9_9_5_5_T_:6_b6_T_M_6_T_7_*7_R7_z7_7_7_7_8_B8_j8_8__SK_
9_29_Z9_L"_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_X>_9_i_v3_>_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_|M_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_M_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_<N_v3_?_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_M_v3_3_4_-4_U4_}4_4_4_5_H_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_T?_@_7@_}4_4_4_5_15_O5_4_m5_5_9_i7_i7_i7_i7_i7_9_}}_}}_i7_i7_i7_a_a_a_A_/_A_K_.L_K_L____0_;_;_;_;_9_}}_}}_;_;_<_0_a_a_C R e s o u r c e I n s t a n c e _ S t a t e _ W i t h d r a w   -   m _ u l L o g R e c B y t e C o u n t   = =   0 x F F F F F F F F   5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_Q_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7__z7_7_D_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_:_9_i_v3_:_4_-4_U4_}4_4_;_5_15_O5_4_m5_5_9__5_5_6_:6_b6_+_M_6_9"_7_%`_R7_z7_7_c;_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6__*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_R_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_;_9_/N_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_aA_6_7_*7_R7_z7_5R_7_7__B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_;_5_9_@_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_\R_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7__7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_KJ_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7__7_D__8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_L<_9_i_v3_<_4_-4_U4_}4_4_4_<_15_O5_4_m5_5_9_9_5_5_T_:6_b6_T_M_6_T_7_*7_R7_z7_7_7_7_8_B8_j8_8__SK_
9_29_Z9_L"_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9__5__6_:6_b6_6_M_6_6_7_*7_R7_z7_7_A_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_'_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_qA_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9__5__6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_T_9_5_5_6_:6_b6_6_M_6_6_7_o_R7_z7_7_o_7_8_B8__*_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_=_4_-4_U4_}4_4_4_5_15_"E_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_R_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9__=_5_6_:6_b6_+_M_6_9"_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_@_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_R_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_S_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_o_R7_z7_7_M_7_8_B8_j8_*_8_8_&"_M_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_9_9_i_v3_=_4_-4_U4_}4_4_4_5_15_TF_4_m5_5_9__5__6_:6_b6_6_M_6_6_7_*7_R7_z7_7_A_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_`_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_5_5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_7_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L_7S_9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9__5_5_6_:6_b6_6_M_6_6_7_*7_R7_z7_7_9_7_8_B8_j8_8_8_8_
9_29_Z9_9_B_J_1B_9_9_K_[B_B_IK_sK_B_ :_K_VC_B_C:_C_)C_K_K_C_L__9_i_v3_3_4_-4_U4_}4_4_4_5_15_O5_4_m5_5_9_m<SF.-$PLqnld:\xpsp\com\com1x\dtc\dtc\tm\src\tmexport.cpp P_%Q_P_P_MQ_uQ_Q_+`_9_P_%Q_P_P_W_uQ_Q_R_9_P_%Q_P_P_MQ_uQ_Q_R_9_P_%Q_M`_P_MQ_uQ_Q_9_9_P_%Q_P_P_MQ_uQ_W_9_9_P_W_`_P_MQ_uQ_Q_ _9_S_eN_wN_V_`V_V_<V_ _OV_N o t   F o u n d   H o s t   N a m e   N o t   F o u n d   `_%Q_`_P_MQ_{W_Q_Q_9_fb_f_b_b_Gg_9_9_fb_f_b_Wg_c_5c_9_fb_f_b_b_c_9_9_Ub_ _K____d:\xpsp\com\com1x\dtc\dtc\tm\src\tmextendedwhereabouts.cpp g_f_b_b_c_9_9_:c__0__9_g_9_]_ _Lr_sr_h__g__o_e_*h__Y_4_r_r_h__g__o_e_*h__Y_4_r_:c__0__9_q_9_]_ _:c__0__9_q_9_]_ _d:\xpsp\com\com1x\dtc\dtc\tm\src\tmgatewayfind.cpp _$_'_L__~____ __H_p_____$_L_9_9__Y_O_L_t_~____ _t_H_p_____$_L_9_9__$_O_L_t_~____ _t_H_p_____$_L_J_9__$_O_L_t_~____ _t_H_p______L_9_9__$_O_L_t_~_____t_H_p_____$_L_0_9___O_L_t_~____ _t_H_p_____$_L_9_9__$_O_L_t_~____ _t_H_p_____$_L_9_9__$_O_L_t_~____ _t_H_p_____$_L_l_9__$_O_L_t_~____ _t_H_p_____$_L_\_9__$_O_L_t_~____ _t_H_p_____$_L_9_9__$_O_L_t_~____ ___p_____$_L__9__$_O_L_t_~____ ___p_____$_L__9___O_L_t_~____ _t_H_p_____$_L_<_9__$_O_L_t_~____ _t_H_p_____$__d_9__$_O_L_t_~____ _t_H_p____=_$_L__9__$_O_L_t_____ _t_H_p_____$_L_9_9__$_O_L_t_~____ _t_H_p__d___$_L_9_9_d:\xpsp\com\com1x\dtc\dtc\tm\src\tmgatewayinstance.cpp _Y_____~__._@_R__o___p_h_Ci__i_,_,_**_____&__$_O_L_t_~____ _t_H_p____ _$_L__9___U_}_____'_9_9___U_}_____'_9_9__-_U_}_____'_!_9__-_U_}_____'_9_9__-_U_}_______9__-_U_}______$_9__-_U_}______$_9_>_F_U_}_____'_9_9__-_U_}__'___'_9_9__-_w_}_____'_9_9_f_-_U_}_____'_9_9__-_U_}__|___'_9_9_d:\xpsp\com\com1x\dtc\dtc\tm\src\tmgatewayinstancescan.cpp _'______%_>_P__-_U_x_____'_9_9____G__9_9____[_o_9_9____G_o_9_9_d:\xpsp\com\com1x\dtc\dtc\tm\src\tmgatewayprotocol.cpp _A___G_o_9_9________h__g__o_e_*h__Y_4_:c__0__9_@_9_]_ _d:\xpsp\com\com1x\dtc\dtc\tm\src\tmgatewaysubordinate.cpp _b__B__________J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____9_9_i______L___"_@_^_|____w_R___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____4_9_i__\____L___"_@_^_|____w_R_9__J_T_9_9_T_M__T_!____#_N_y____%__SK____L"_Z___}_________r__E__>_d_____9_9_i______L___"_@_^_|____w_R___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d______9_i__[____L___"_@_^_|____w____J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____9_9_i__[____L___"_@_^_|____w_R___J_u___+_M__9"_!_%`___#_o_y____%_P_{____'_Z___}_________r__E__>_d______9_i__[____L___"_@_^_|____w_R_9__J_T_9_9_T_M__T_!____#_N_y____%__SK____L"_Z___}_________r__E__>_d_____O_9_i__|____L___"_@_^_|____w_R_9__J_T_9_9_T_M__T_!____#_N_y____%__SK____L"_Z___}_________r__E__>_d______9_i______L___"_@_^_|____w_R__9_J_T_9_9_+_M__9"_!____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____@_9_i__[____L_o__"_@_^_|__#__w_R___J_T_9_9_+_M__9"_!_%`___#_o_y____%_P_{____'_Z___}_________r__E__>_d_____R_9_i__[____L_o__"_@_^_|___3_w_R_9__J_T_9_9_T_M__T_!____#_N_y____%__SK____L"_Z___}_________r__E__>_d_____*_9_i______L___"_@_^_|____w_R__2_y__F____Z___a_a_0___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d______9___[____L_9__"_9_9_|__9_9_w_R___J_u_9_9__M___!____#__y____%_P_{____'_Z___}_________r__E__>_d_____;_9_i__c____L___"_@_^_|___9_w_R___J__9_9__M___!_%`___#_o_y____%_P_{____'_Z___}_________r__E__>_d_____9_9_i__[____L_o__"_@_^_|___3_w_R___J_u_9_9__M_______#_N_y____%_P_{____'_Z___}_________r__E__>_d_____9_9_i__[____L___"_@_^_|____w_R___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d______9_i__[____L___"_@_^_|____w_R___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d______9_E__[____L___"_@_^_|____w_R___J_u_9_9__M_z __!_____N_y____%_P_{____'_Z___}_________r__E__>_d_____9_9_9__F_&___L____@_^_|____w_R_@___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d______9_i__[____L___"_@_^_|____w_R___J_u_9_9__M___!_____N_y____%_P_{____'_Z___}_________r__E__>_d_____U_9_i__{____L___"_@_^_|____w_R___J_u_9_9__M___!____#______%_P_{____'_Z___}_________r__E__>_d______9_i______L____@_^_|____w_R_9__J_T_9_9_T_M__T_!____#_N_y____%__SK____L"_Z___}_________r__E__>_d_____9_9_i__[____L___"_@_^_|____w_R____u_9_9__M___!____#_A_y____%_P_{____'_Z___}_________r__E__>_d______9_i______L___"_@_^_|____w_R___J_u_9_9__M___qA____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____9_9_i__[____L___"_@_^_|____w_R____u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____9_9_i__[_S___L___"_@_^_|____w_R_T_{__J_u_9_9__M___!_o___#_o_y____*_P_{____'_Z___}_________r__E__>_d_____9_9_i______L_o__"__*_|___9_w_R___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____3_9_i__[____L___"_@_^_|____w_R__=_J_u_9_9_+_M__9"_!____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____@_9_i__[____L___"_@_^_|____w_R___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d_____{_9_i__[____L___"_@_^_|____w_R___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d______9_i__[____L___"_@_^_|____w_R___J_u_9_9__M___!_o___#_M_y____*_P_{_&"_M__'_Z___}_________r__E__>_d_____9_9_i______L_o__"_@_*_&"_M__9_w_R____u_9_9__M___!____#_A_y____%_P_{____'_Z___}_________r__E__>_d_____`_9_i__[____L___"_@_^_|____w_R___J_u_9_9__M___!____#_N_y____%_P_{____'_Z___}_________r__E__>_d______9_i__[____L___"_@_^_|____w_R___J_u_9_9__M___!____#_9_y____%_P_{____'_Z___}_________r__E__>_d_____%`_9_i__[____L___"_@_^_|____w_R_d:\xpsp\com\com1x\dtc\dtc\tm\src\tmgatewaysuperior.cpp _S__9_9____9_9____9_9_d:\xpsp\com\com1x\dtc\dtc\tm\inc\TMSupTem.H _h__g__o_e_*h__Y_4_K__ _____t._9_V_s______$_O_l__d:\xpsp\com\com1x\dtc\dtc\tm\inc\TMSupIf.H :c__0__9__9_]_ _-_p__d_____A__u_'_x_N_____9_"___-_p__d_____A__u_'_x_N____9_9____-_p__d_____A__u_'_x_N_____9_______9_9_____%___0_X_____ _H_p__`,_,_9___9_9_9_9_9_9_9____-_!_K__u____W_#_M_w_____I_s_____E_o________*_9___0_X_____ _H_p__`,_,_9_9__9_9_9_9_9_9_9____-_!_K__u____W_#_M_w_____I_s_____E_o_________9___0_X_9_9___ _H_p__`,_,_9_9__9_9_9_9_9_9_9____-_!_K__u____W_#_M_w_____I_s_____E_o_________9___0_X_____ _H_p__`,_,_9_9__9_9_9_9_9_9_9____-_!_K__u____W_#_M_w_____I_s_____E_o_____